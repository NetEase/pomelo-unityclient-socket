{
  "name": "pomelo-loader",
  "version": "0.0.6",
  "dependencies": {},
  "devDependencies": {
    "mocha": ">=0.0.1",
    "should": ">=0.0.1"
  },
  "contributors": [
    {
      "name": "* Yongchang Zhou",
      "email": "changchang005@gmail.com"
    }
  ],
  "readme": "#pomelo-loader - loader module for pomelo\n\nLoad codes for pomelo based on the convention over configuration rules.\n\npomelo-rpc could load modules in batch but not load the sub-directory recursively.\n\n+ Tags: node.js\n\n##Regulation\nModule name\n\nModule would use the filename by default. For example: load ```lib/a.js``` and the return result would be: ```{a: require('./lib/a')}```\n\nIt would use the name if the module with a name property. For example\n\n```javascript\na.js\nexports.name = 'test';\n```\nthe return result would be: ```{test: require('./lib/a')}```\n\nModule definiation\n\nIf the module exported as a function, pomelo-loader would take it as a factory method and generate a new instance of module by calling the function. And it would return the module directly for other situation.\n\n```javascript\nmodule.exports = function(context) {\n\treturn {};\t// return some module instance\n};\n```\n\n##Installation\n```\nnpm install pomelo-loader\n```\n\n##Usage\n``` javascript\nvar Loader = require('pomelo-loader');\n\nvar res = Loader.load('.');\nconsole.log('res: %j', res);\n```\n\n##API\n###Loader.load(path, context)\nLoad all modules in the path.\n####Parameters\n+ path loaded path\n+ context if the module provides a factory method, the context would be pass as a parameter as the factory method.\n",
  "readmeFilename": "README.md",
  "description": "Load codes for pomelo based on the convention over configuration rules.",
  "_id": "pomelo-loader@0.0.6",
  "_from": "pomelo-loader@0.0.6"
}
